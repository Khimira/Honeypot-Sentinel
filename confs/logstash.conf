input {
  beats {
    port => 5045
    host => "0.0.0.0"
  }
}

filter {
  # 1. Attempt to decode JSON. If it fails (plain text), don't generate fatal error
  json {
    source => "message"
    target => "cowrie_data"
    skip_on_invalid_json => true
  }

  # 2. Plain Text Processing (Ensures CMD: and Connection Lost work)
  if ![cowrie_data] {
    if [message] =~ /^CMD:/ {
      mutate {
        add_field => { "[cowrie_data][eventid]" => "cowrie.command.input" }
        add_field => { "[cowrie_data][session]" => "manual_session" }
        add_field => { "[cowrie_data][src_ip]" => "127.0.0.1" }
      }
      mutate {
        copy => { "message" => "[cowrie_data][input]" }
        gsub => [ "[cowrie_data][input]", "CMD: ", "" ]
      }
    }
    if [message] =~ /Connection lost/ {
      mutate {
        add_field => { "[cowrie_data][eventid]" => "cowrie.session.closed" }
        add_field => { "[cowrie_data][session]" => "manual_session" }
      }
    }
  }

  # 3. Aggregation Logic (Accumulates commands in memory)
  if [cowrie_data][eventid] == "cowrie.command.input" {
    aggregate {
      task_id => "%{[cowrie_data][session]}"
      code => "map['cmds'] ||= []; map['cmds'] << event.get('[cowrie_data][input]')"
      map_action => "create_or_update"
    }
    drop { } # Never trigger n8n webhook here
  }

  # 4. Trigger Dispatch (Only on session close or 10-minute timeout)
  if [cowrie_data][eventid] == "cowrie.session.closed" {
    aggregate {
      task_id => "%{[cowrie_data][session]}"
      code => "event.set('commands_list', map['cmds'])"
      map_action => "update"
      end_of_task => true
      timeout => 600  # 10 minutes
    }

    # Prepare JSON for n8n webhook
    mutate {
      copy => { "cowrie_data" => "[body][cowrie_data]" }
      copy => { "commands_list" => "[body][commands_list]" }
    }
  } else {
    # Discard everything else (login, kex, system tags)
    drop { }
  }
}

output {
  http {
    url => "http://your-n8n-instance:5678/webhook/honeypot_logs"
    http_method => "post"
    format => "json"
  }
  stdout { codec => rubydebug }
}
